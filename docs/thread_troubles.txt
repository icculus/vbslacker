These are difficulties that will arise for VBslacker if we try to
implement multithreading in the code. If we make ourselves aware of
problems now, they won't bite us in the ass later.

- Linux is still not to the point of having a clean, efficient, safe, and
STANDARD thread library. Glibc2 (the standard on Red Hat and some other
distributions, and the inevitable future of linux) has a thread package
that is to be the standard, but it doesn't come by default in the library.
You have to add another package into the source, define some flags, and
recompile the library, which is a good 2 hours worth of processing on a
pentium. Ugh. Ignoring that, though...

- Most (if not all) of the problems come from global and static variables.
Expect to be thinking about how to protect that data, and writing an entry
in this file if you use any. 

- _stack_ptr_ needs to be protected. This can be done by (whatever the
equivalent is on linux...) EnterCriticalSection() and
ExitCriticalSection() calls surrounding the __registerOnEventsHandler()
call, generated by the parser/compiler with only the absolutely tinyest 
performance hit. This would be the safest way for this, so we don't fuck
the stack anymore than needed by trying to figure out WHERE to store the
stack pointer in a table of thread-specific data. Plus, it's easiest, and
probably LESS of a performance hit than all that.

- The Event Handler tables in OnEvent.c need to be organized by thread. As
we pile up handlers, we know when to add or replace based on the location
on the stack. This will cause problems, since each thread has its own
stack, and handlers will be piling over each other, and we'll end up
calling the handler for a different thread than the one that triggered the
event. The best solution will be to put the current handler table
structure into an array or multiple tables that are indexed by thread ID or
something.

/* end of thread_troubles.txt ... */


