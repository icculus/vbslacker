These are difficulties that will arise for VBslacker if we try to
implement multithreading in the code. If we make ourselves aware of
problems now, they won't bite us in the ass later.

- Linux is still not to the point of having a clean, efficient, safe, and
 STANDARD thread library. Glibc2 (the standard on Red Hat and some other
 distributions, and the inevitable future of linux) has a thread package
 that is to be the standard, but it doesn't come by default in the library.
 You have to add another package into the source, define some flags, and
 recompile the library, which is a good 2 hours worth of processing on a
 pentium. Ugh. Ignoring that, though...

- Most (if not all) of the problems come from global and static variables.
 Expect to be thinking about how to protect that data, and writing an entry
 in this file if you use any. 

- _stack_ptr_ and _base_ptr_ (defined in OnEvents.c) need to be protected. 
 This can be done by __enterCriticalThreadSection() and
 __exitCriticalThreadSection() calls surrounding the __registerOnEventsHandler()
 setup and call, generated by the parser/compiler with only the absolutely
 tinyest performance hit. This would be the safest way for this, so we don't
 fuck the stack anymore than needed by trying to figure out WHERE to store the
 stack pointer in a table of thread-specific data. Plus, it's easiest, and
 probably LESS of a performance hit than all that.

- Simplest solutions: Add a function to your module called (for example)
  "void __initThreadMyModule(int tidx)", and add a call to it inside of
  __initThread(int tidx) (found in Initialize.c). This new function will be
  called whenever a new thread is created, with tidx set to the thread index
  of the new thread. This will allow you to update thread-separated arrays and
  such. Be careful about reallocating arrays, since this function can be called
  happen at any time, so any access to those array elements will be to be
  protected by critical sections or something.

- The same rules apply for thread termination...add your notification function
  calls to __deinitThread(int tidx) in Initialize.c ...

- The best idea is just to avoid global and static data wherever possible.

- basicErrno and __basicErrno (in ErrorFunctions.c) will need thread-proofing.

/* end of thread_troubles.txt ... */


