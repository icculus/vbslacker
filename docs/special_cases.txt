APIs that need special handling in the parser/compiler:

PRINT (and print #), with more than one parameter (separated by semicolons)
 must be broken into multiple calls. Strings concatenations should be done
 prior to breaking down the API call. That is, PRINT "crack" + "pipe" would
 be one call, but PRINT "crack"; "pipe" would be two. ALSO -- Semicolons at
 the end of the PRINT statement specify that no newline should be sent to the
 console. This will need to be handled specifically. Solution: the print call
 should, by the parser/compiler, do this: Break down semi-colon separated
 fields into variants, make a call to vbpV_print(), which will convert
 whatever the data was from a variant type to a string, and print it. If there
 is no semicolon at the end of the line, the parser/compiler will generate a
 call to __printNewLine() (an internal function) after all the vbpV_print()
 calls. Note that the __printNewLine() call might be the only call generated,
 if there are no parameters to the BASIC PRINT statement. If, for some
 crazy reason, a programmer has decided to put a "PRINT ;" statement, the
 line will not generate any C code, but will still produce proper line
 labling and debug/tracing code.

OPEN calls should all call one function, with default values for optional
 missing values. The OPEN function should determine what action to take
 based on the default values. This avoids the need for 18 jazillion overloaded
 functions.

CLOSE needs to be broken down into multiple calls. CLOSE 1, 2, 3 should be be
 converted into vbpi_close(1); vbpi_close(2); vbpi_close(3); Furthermore,
 CLOSE with no arguments must still call the correctly named vbp_close().
 ALSO -- Optional '#' chars before the numbers need to be dealt with.

SWAP can probably be generated inline by the parser/compiler.
"SWAP a, b" becomes "tmp = a; a = b; b = tmp", plus type/range checking and
debug/trace code.

Ugh.
