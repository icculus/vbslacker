BASIClib is (hopefully) threadsafe, and has an abstraction layer for
creating and managing threads. Here's all you need to know:

- Linux is still not to the point of having a STANDARD thread library.
  Glibc2 (the standard on Red Hat and some other distributions, and the
  inevitable future of linux) has a thread package that is to be the
  standard, but it doesn't come by default in the glibc2 library.
  You have to add another package into the source, define some flags, and
  recompile the library, which is a good 2 hours worth of processing on a
  pentium. Ugh. (Actually, Red Hat 5.1 seems to package their binary glibc2
  with LinuxThreads compiled in. Good.)

- There's NO POSIX threads on Win95. Cygnus is working on this, but god
  knows how long it will take them to write a POSIX compliant pthreads
  package AND make all their libraries thread-safe. WinNT has some DCE
  threads libraries (older draft of POSIX standard) bundled with the OS,
  but this is not 100% compatible with Linux (POSIX standard) threads.

Ignoring those as "problems that will fix themselves," however...

- For reference, the thread abstraction layer is defined in
  BASIClib/Threads.c ... The current implementation uses POSIX threads, but
  there's no need to concern yourself with the underlying library.

- You should #include "Threads.h" in any modules that use threads in anyway.
  You should ALSO define _REENTRANT on the command line for gcc.

  gcc -D_REENTRANT MyCode.c

  _REENTRANT changes the behavior of the C library headers to be thread safe.
  (Most notably, errno works in a downright wrong way if you don't use this.)
  YOU SHOULD DEFINE _REENTRANT EVEN IF YOU DON'T DIRECTLY USE THREADS.
  Threads could be calling your functions, even if you don't specifically
  make a thread do so. Including Threads.h and not defining _REENTRANT will
  cause an error, but this check isn't foolproof, since not every module
  will include Threads.h ...

- Spin a thread like this:

  void myThreadEntryPoint(void *_args)
  {
      MyDataType *args = (MyDataType *) _args;
      /* do something. */
  } /* myThreadEntryPoint */

  void main(void)
  {
          /*
           * The NULL can be a pointer to anything you like. It will
           * be passed to myThreadEntryPoint()...
           */
      __spinThread((void *) myThreadEntryPoint, NULL);
  } /* main */

- Every thread has an index number (a "tidx," or "Thread Index"). The first
  thread, the one that runs the mainline, is index (0). The next thread spun
  is index (1). As threads are destroyed, their index numbers are recycled
  for new threads that are spun. You can find out the currently executing
  thread by calling __getCurrentThreadIndex(). It will return the index of
  the thread that called the function.

- Threads are destroyed automatically when they return. You can have one
  destroy itself by calling __terminateCurrentThread(). You can kill other
  threads, if you know its thread index, by calling __terminateThread(tidx)...
  the behavior is undefined if you call __terminateThread() with the current
  thread's index.

- Behavior is ALWAYS undefined if you try to manipulate threads with any
  functions other than BASIClib's threads API. Don't assume that the
  underlying code is a POSIX implementation, or even the WIN32 API, if
  even if you are running under Windows...maybe we got witty and created
  a "green threads" package that runs multiple threads on one.

- Most (if not all) of the problems will come from global and static variables.
  Expect to be thinking about how to protect that data, and writing an entry
  in this file if you use any that will affect other modules (like 
  _stack_ptr_ and _base_ptr_, below.)

- There is no EnterCriticalThreadSection() API in the POSIX standard. Use
  BASIClib's ThreadLocks instead. This is a abstraction layer over POSIX
  mutexes. Like so:

  (at top of module:)

  #include "Threads.h"

  ThreadLock myThreadLock;

  (in init code for module:)

  __createThreadLock(&myThreadLock);

  (Whenever you need to protect data from race conditions...)

  __obtainThreadLock(&myThreadLock);
  /* Mess with data... */
  __releaseThreadLock(&myThreadLock);

  (in deinit code for module:)

  __destroyThreadLock(&myThreadLock);

  Try to group sensitive data by ThreadLocks, so we don't hog too much
  memory with a ThreadLock for every bit of data, but there is enough
  locks in the right places so there aren't any massive slowdowns while
  threads wait unnecessarily to obtain a lock. Use common sense.

- If you have to wait for a thread to die for any reason, you can call
  __waitForThreadToDie(tidx), and the calling thread will block until
  the thread with index (tidx) terminates. Be careful whenever blocking
  is involved, like this.

- If your thread is looping for any amount of time, it might be wise to
  place a call to __timesliceThread() in your loop. This call surrenders
  control of the processor so other threads and processes can use it.
  Eventually control will return to the caller. VERY handy when waiting
  endlessly for user input.

- For accounting purposes, you can call __getThreadCount(), which returns
  a count of all threads in this process...although this isn't as useful
  as __getHighestThreadIndex(), which returns the highest thread index in
  use. This is good for allocating arrays that keep one element for each
  thread, since such arrays are inherently thread-safe.

- To be notified when a thread is created, add a function to your module
  called (for example) "void __initThreadMyModule(int tidx)", and add a
  call to it inside of __initThread(int tidx) (found in Initialize.c).
  This new function will be called whenever a new thread is created, with
  tidx set to the thread index of the new thread. This will allow you to
  update thread-separated arrays and such. Be careful about reallocating
  arrays, since this function can be called happen at any time, so any
  access to those array elements will need to be protected by ThreadLocks.
  The newly created thread will be the one to call __initThread().

- The same rules apply for thread termination...add your notification
  function calls to __deinitThread(int tidx) in Initialize.c ... The
  thread that did the terminating (the one who called __terminateThread()
  or __terminateCurrentThread()) will be the one to call __deinitThread().

- The best idea is just to avoid global and static data wherever possible.
  Remember  that every thread has it's own stack, and data stored on it will
  be separate from other functions...therefore local variables and arguments
  are thread-proofed already. This doesn't solve EVERY problem, but keep it
  in mind.

- _stack_ptr_ and _base_ptr_ in OnEvents.c need to be protected. Use the
  ThreadLock (registerLock), also declared in OnEvents.[c,h]...

- basicErrno and __basicErrno (in ErrorFunctions.c) will need thread-proofing.

/* end of thread_notes.txt ... */


