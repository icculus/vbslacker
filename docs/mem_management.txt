vbSlacker's memory manager API.

vbSlacker offers three levels of memory management for the C programmer.
These techniques are used in BASIClib as well as code generated by the
parser/compiler, and may also be used by linked C code, if so desired.

The levels are, abstractly:
- standard C library's malloc(), realloc(), and free().
- BASIClib's __memAlloc(), __memRealloc(), and __memFree().
- BASIClib's Boxcar Memory Management API ("assisted garbage collection").

Let's analyze each of these separately, shall we?

STANDARD C LIBRARY MEMORY MANAGEMENT LEVEL:

First, the programmer may always call malloc(), realloc(), free(), and
related functions like calloc(). These are always handy, since they are
portable between platforms, and pretty flexible at the expense of having
to check errors from every call manually. BASIClib knows nothing of calls
to these functions, so they will not trigger BASIC runtime errors, and
they will not interfere with the other two higher-level memory management
APIs.

In short, the C library functions just like you'd expect it would.

Never mix calls to the C library's memory management functions with
BASIClib's. That is, don't call __memFree() on something you've malloc()ed,
don't call realloc() on things you've __memAlloc()ed, etc...

...and you should probably, for your own ease of coding, avoid these calls
anyhow, but it's nice to know they're there. Some of the lower-level sections
of BASIClib use malloc() and free()...


STANDARD BASICLIB MEMORY MANAGEMENT LEVEL:

BASIClib has it's own versions of malloc(), realloc(), and free(). They
expect STATEARGS to be passed to them, like all BASIClib functions, but
other than that, the syntax is the same. Therefore, the BASIClib equivalents
of the C library are:

/* C versions: */

void *malloc(size_t memLength);
void *realloc(void *ptr, size_t memLength);
void free(void *ptr);

/* BASIClib versions: */

void *__memAlloc(STATEPARAMS, size_t memLength);
void *__memRealloc(STATEPARAMS, void *ptr, size_t memLength);
void __memFree(STATEPARAMS, void *ptr);

(The implementation of calloc() is left as an exercise to the reader. If you
can't do this, then you probably can't hack it as a programmer.)

The difference? First, if the requested memory object cannot be allocated,
BASIClib tries to free unneeded memory, and allocate again. When this option
is completely exhausted, BASIC runtime error #7 (ERR_OUT_OF_MEMORY) is thrown.
After all, what do you plan to do when you run out of memory? __memFree()
should be used just like free(), but only on values returned by __memAlloc()
and __memRealloc(). There is no guarantee that __memAlloc() is just another
layer over malloc(), either, so don't expect that free() will necessarily be
an acceptable replacement for __memFree(). Maybe we used sbrk() or mmap()
instead of malloc(). And maybe we'll write a real garbage collector someday,
in which case __memFree() will do a lot more. At any rate, just don't mix
APIs. I can't stress this enough.


BASICLIB BOXCAR MEMORY MANAGEMENT LEVEL:

First, a little history...
The problem with C and C++ (and lower-level languages) is that memory
management is done manually, which leads to potential "memory leaks". One
solution is to implement a GARBAGE COLLECTOR, which scans an application's
heap, stack, and static data to find if pointers to allocated memory still
exist. In the absence of a given pointer, the allocated object is considered
"garbage" (since there's no pointers to it, it's inaccessable, so it's just
taking up space.) and is free()d. Recent studies have shown that modern
garbage collection algorithms are as fast (if not faster) than manual memory
management (especially when you have to do some real programming aerobics to
keep track of all your allocated objects), and remove the problem of memory
leakage.

That doesn't make such systems perfect, however. The problem with such systems
is that they have to work against C/C++. They are not portable in the least
between hardware architectures (and frequently even operating systems on the
same architecture), they are somewhat contrary to concepts like destructors,
they don't like pointer manipulation, and data alignment is hard to control in
C and impossible to control in C portably.

Did we mention that garbage collectors are a bitch to implement?

If you want GOOD garbage collection, write in Java or Perl or any other
modern language. The vbSlacker parser converts BASIC to C for compilation
into binary code for the sake of portability, and BASIClib is written in C.
In short, a happy garbage collector is unlikely. If the parser/compiler
generated the binary code itself, we could implement a garbage collector
with relative ease, but would immediately lose portability (besides, a good
optimizing C compiler that's been developed for years is going to produce
better code than we ever could.)

So, the vbSlacker development team has lived up to its moniker and developed
a half-hearted garbage collector. This "slack" collector is termed the
"boxcar" system (which is only slightly similar to the "boxcar" garbage
collecting paradigm in Sun Microsystem's "hotspot" Java virtual machine).
We call it "assisted garbage collection." Basically, this system has a few
benefits:

- It handles most "garbage collection" automatically.
- It prevents leakage that would be caused by the throwing of runtime errors.
- It is faster and more efficiently than a garbage collector, since there's no
   guesswork involved, or scanning of memory for pointers.
- With the exception of two macros, it is completely portable.
- It works with C and C++, not against them.

The boxcar system still needs some attention from the programmer, unlike a
garbage collector. With a garbage collector, you just "allocate and forget,"
whereas with the boxcar system, you need to specify which pointers will be
expendable, and which should not be automatically cleaned up, and when their
status has changed. It takes a little more work than garbage collection, but
somewhat less work than manual memory management. In the long run, you
can STILL have memory leaks, but there is significantly less chance of it.

...it doesn't handle the "new" and "delete" instructions in C++. At least, not
right now. The boxcar system may still be used from C++ to allocate/free
memory objects, though; just not classes.

Here's how to use it.

In any function, before the first call to a boxcar API, be sure your STATEARGS
reflect the current function:


__setResumeStack;    /* put this at the top of the function. */

To allocate memory, call __memAllocInBoxcar(STATEARGS, objSize);
                     or  __memReallocInBoxcar(STATEARGS, oldPtr, objSize);

To manually free memory, call __memFreeInBoxcar(STATEARGS, ptr);

You shouldn't need to manually free pointers in boxcars, but you can with
the above function.

When you allocate this way, BASIClib keeps track of what part of the stack
a given memory object is associated with. This is determined by examining
the STATEARGS variables. All the memory objects associated with a given
part of the stack make up a "boxcar" on the memory "train".

The theory is, for the most part, when we shrink the stack, all the objects
allocated in functions that have returned are garbage. Therefore, to get
rid of allocated garbage, we need to just release all the boxcars that are
past the end of the stack. There are two ways to do this:

void __memForceFullBoxcarRelease(STATEPARAMS);
boolean __memForcePartialBoxcarRelease(STATEPARAMS);

The former API will free all the objects associated with returned-from
functions. Depending on how much was allocated, this might take awhile, and
blocks until complete. Therefore, we also offer the "partial" version of
this API, which releases boxcars until at least X pointers have been freed,
and returns. X is a constant compiled into BASIClib (usually about 20), and
may be overridden, if an environment variable named VBSLACKCOLLECT is set to
a different numeric. The partial version is good for idle loops, and returns
boolean (true) if there are more boxcars to free, (false) otherwise.
__mem(re)Alloc() calls __memForcePartialBoxcarRelease() in a loop until it
either manages to allocate memory, or we run out of boxcars to release.

Here's where it becomes "assisted:" Let's say you allocate a String for a
return value. It needs to be in a boxcar in case there's a runtime error
thrown, to avoid leakage. The Runtime Error OnEvent handler releases
boxcars, too. However, if you return this String, when the garbage collector
releases that boxcar, regardless of how that String is being used, the data
pointed to by the return value has been freed. So, you need to assist the
garbage collection by informing BASIClib that a pointer needs to be removed
from its boxcar. The API:

void __memRemovePtrFromBoxcar(STATEPARAMS, void *ptr);

Just notifies BASIClib that (ptr) should not be considered as part of the
boxcar any longer. This should be done for return values and global values.

Return values will need to be moved into a NEW boxcar, though, so we have
this function:

void __memAddPtrToBoxcar(STATEPARAMS, void *ptr);


So that you might have something like this:

#include "StdBasic.h"

char *__myFunc2(STATEPARAMS);
{
    char *retVal;

    __setResumeStack;

    retVal = __memAllocInBoxcar(STATEARGS, 15);

    /* do stuff... */

    __memRemovePtrFromBoxcar(STATEPARAMS, retVal);
    return(retVal);
}

void __myFunc1(STATEPARAMS)
{
    char *rc;

    __setResumeStack;

    rc = __myFunc2();
    __memAddPtrToBoxcar(STATEARGS, rc);
}

If you don't call __setResumeStack, BASIClib uses the boxcar from the latest
function on the stack that called __setResumeStack...

__memAlloc(), __memRealloc(), and __memFree() cannot be used with the Boxcar
API, since it'll confuse the collector. There are equivalents, though.

/* end of memory_management.txt ... */



