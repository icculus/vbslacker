The vbSlacker OnEvents subsystem.

Part of the reason why BASIC isn't so cross-platform is not because there's
no desire for it in the cyber community, but because to implement a BASIC
system, you need a development team that codes like a god, but thinks like
a kindergartener.

The biggest stumbling block in making a BASIC system is the error handling.
It's kinda like C++ and Java's try/catch blocks, but considerably less
structured. Here's a brief comparison between BASIC and Java:

public void throwsError(PrintWriter writer)
{
    try
    {
        writer.println("Write this string to file.");
    } // try

    catch (IOException ioe)
    {
        System.out.println("IOException writing to file!");
    } // catch
} // throwsError


in BASIC:

SUB throwsError(fileNo AS INTEGER)
    ON ERROR GOTO IOEXCEPTION
    PRINT #fileNo, "Write this string to file."
    EXIT SUB

IOEXCEPTION:
    PRINT "IOException writing to file!"
END SUB


Implementation of this sort of error handler is complicated enough, since we
need to play with the stack, but when we consider the the language's RESUME
command, we have something truely complicated.

Here's our solution, in a nutshell.

First a practical example is needed, then we'll break it down.

Here's an error handler in BASIC, and what vbSlacker (roughly) produces from it:

---

SUB throwsError
    ON ERROR GOTO fixme
    PRINT #15, "Text!"
    EXIT SUB

fixme:
    OPEN "text.txt" FOR OUTPUT AS #15
    RESUME 0
END SUB

throwsError

REM end of program...

---

#include "BasicLib.h"

PBasicString i0;
PBasicString i1;

void throwsError(STATEPARAMS)
{
    __setStateStacks;

    __setStateInstructs(&&ln0, &&ln1);
ln0:
    __registerOnEventHandler(STATEARGS, &&ln3, ONERROR);

    __setStateInstructs(&&ln1, &&ln2);
ln1:
    vbpiS_Print_NC_(STATEARGS, 15, i0);

    __setStateInstructs(&&ln2, &&ln3);
ln2:
    __deregisterOnEventHandlers(STATEARGS);
    return;

    __setStateInstructs(&&ln3, &&ln4);
ln3:
    vbpS1i_open(STATEARGS, i1, VBOPEN_OUTPUT, 15);

    __setStateInstructs(&&ln4, &&ln5);
ln4:
    __resumeZero(STATEARGS);

    __setStateInstructs(&&ln5, &&ln5);
ln5:
    __deregisterOnEventHandlers(STATEARGS);
    return;
}


int main(int argc, char **argv, char **envp)
{
    __initBasicLib(NULLSTATEARGS, INITFLAG_NO_FLAGS, argc, argv, envp);

    i0 = __constString("Text!");
    i1 = __constString("text.txt");

    throwsErrors(NULLSTATEARGS, NULL);

    __deinitBasicLib(NULLSTATEARGS);
}

/* end of program. */

If vbSlacker optimizations are enabled, specifically "disable RESUME",
then the code becomes a LOT more efficient. The __setStateStacks and
__setStateInstructs commands are not used, and the line labels are not
generated, except "ln3", which translates directly to "fixme" in the BASIC
version. The RESUME command needs to know the instruction pointer before each
line of code for "RESUME 0" calls, which rerun lines of code, and the next
line of code's instruction pointer for "RESUME NEXT" calls, which skips
arbitrary instructions. If you "disable OnEvents," not only do you lose the
previously mentioned overhead, but -fomit-frame-pointer is passed to GCC,
which makes a pretty significant difference in code performance, too.

Here's how it works:

ON EVENT GOTO commands can be more than just error handlers, although this is
the most common use. Other uses historically have been ON TIMER, ON COM,
ON STRIG, etc...all of these have been removed in recent Visual BASICs, but
the generic event support has been constructed in vbSlacker anyhow.

A statement on the continual passing of STATEARGS. 

STATEPARAMS looks like this:

#define STATEPARAMS void *__stIP, void *__stNextIP, void *__stBP, void *__stSP

... and STATEARGS:

#define STATEARGS __stIP, __stNextIP, __stBP, __stSP

These variables store the addresses of potential locations of RESUME commands,
and their base and stack pointers. State information, y'know? Good.

This adds 16 extra bytes to the stack for every function call. No one complains
when C++ adds (this) to every non-static function call, and the return address
and base pointer is saved there too in every program...not to mention your
compiler usually allocates more space on the stack than the local variables
need for the sake of optimizations. It's much more efficient than figuring out
in every function not only where to store the current pointers, but it
automatically thread-proofs that data. Without this, we'd have to keep a stack
in memory of all these pointers, which we'd have to concern ourselves with
dynamic resizing of that stack, knowing where the current data is, and for
which thread...no, it's much simple to have the CPU handle it for us with the
rest of the thread's stack. No more on that.

If external code links with BASIClib, it will need to accept STATEPARAMS as
its FIRST parameter, and pass it on, even if it does not explicitly handle
OnEvents. Besides the fact the calling BASIC code will be passing them on
whether your C code uses them or not, the OnEvent handler will grab them from
the stack at the point where the event was triggered, so you'll need to
continue the duplication of this data if nothing else.

But there's an exception. Declaring a function as CDECL prevents the STATEARGS
from being implicitly passed. BUT -- you need to verify that OnEvents will
never be triggered in your code; this means no calling BASIC functions (either
user-written or in BASIClib), and making sure things like ON TIMER GOSUB aren't
going to interrupt your code. Generally, unless this is a tight, speed-driven
function, or you expect stack space to be VERY tight, it's generally safer to
use STATEPARAMS.

If you are brave enough to not use STATEPARAMS in your code, you CAN call
BASIC code by using the NULLSTATEARGS macro in place of STATEARGS. Do so at
your own risk. You cannot use STATEARGS unless you used STATEPARAMS, for
fairly obvious reasons.

STATEPARAMS and other declarations can be found in RegState.h, which is
automagically included by StdBasic.h, BasicLib.h, and most other subheader
files.

When an OnEvent is triggered, it sees if there is an OnEvent handler for that
event type registered. (So if an ON TIMER event is triggered, no one cares how
many ON ERROR handlers exist) OnEvent handlers are registered with the
__registerOnEventHandler() function.

void __registerOnEventHandler(STATEPARAMS, void *handlerAddr,
                              OnEventTypeEnum evType);


All you need to do is pass the type of OnEvent you want to handle, and the
address of the handler. Then, when that OnEvent is triggered, BASIClib will
adjusts the stack, and transfer control to that address.

Adjusts the stack?

Let me clarify. Let's say you have a procedure, butts(), and it registers an
OnEvents handler. It then calls another procedure, which calls another one.
A couple of procedures down the line (and on the stack), one of the procedures
triggers an OnEvent.

+---------+
| proc3() | <---- OnEvent triggered here.
+---------+
| proc2() |
+---------+
| proc1() |
+---------+
| butts() |
+---------+

Control has to drop back into butts() for the handler, which means that we
need to adjust the stack and base pointers to where they were for butts().
This also means that if inside the handler, butts() makes a function call or
allocates any more stack space, proc1() (any maybe proc2 and proc3)'s stack
is overwritten. So, we need to protect that data, in case of a RESUME
statement, which will return us back to otherwise potentially destroyed data.
SO, we allocate memory, copy all the stack beyond butts() to that memory,
set the stack and base pointers back to butts(), and unconditionally jump into
it. If butts() returns from within the handler, we just free that protected
stack buffer, deregister the OnEvent handler, and continue as normal. If a
RESUME command of any type is reached inside the handler, the protected
stack buffer is copied back to the stack, the stack and base pointers are
restored to their pre-event state, and we unconditionally jump back into the
procedure that triggered the OnEvent.

After the OnEvent has been triggered, and before the handler is called, the
return address from butts() is read from the stack, and our cleanup
routine address is patched in, so we can cleanup even if butts() returns.
The stack is repatched from within the cleanup routine and the RESUME functions
with the original address, to prevent crashes.

Events are triggered like this:

void __triggerOnEventByType(STATEPARAMS, OnEventTypeEnum evType);

All you need to know is the type of OnEvent you want to trigger. To generate
a runtime error, you CAN do this (but shouldn't):

__triggerOnEventByType(STATEARGS, ONERROR);

Tada!

Actually, it's wiser to use __runtimeError(), which allows you to specify
what error you want to throw, and abstracts the interface somewhat.


For ON ERROR RESUME NEXT statements, the parser/compiler needs to generate
code like this:


BASIC:

SUB OPENFILE ()
    ON ERROR RESUME NEXT
    OPEN "FEH.TXT" FOR INPUT AS #1
END SUB


C:

void vbp_openfile(STATEPARAMS)
{
    __registerOnEventHandler(STATEARGS, &&l1, ONERROR);
    vbp_open(STATEARGS, "FEH.TXT", 1, INPUT);
    return;

l1:
    __resumeNext(STATEARGS);
}

(This has obviously been simplified for the purpose of illustration...)


Lastly, we've been very careful to always specify these as OnEvents, and not
merely events. These are not to be confused with the event-handling subsystem
of Visual Basic GUI. Those are VERY different.

/* end of on_events.txt ... */


